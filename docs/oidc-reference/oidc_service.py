"""
OIDC authentication service for handling OpenID Connect flows.
"""

from __future__ import annotations
import logging
import secrets
from typing import Dict, Any, Optional
from datetime import datetime, timedelta, timezone
import httpx
from jose import jwt, JWTError
from fastapi import HTTPException, status
from config import settings
from models.auth import OIDCConfig
from settings_manager import settings_manager

logger = logging.getLogger(__name__)


class OIDCService:
    """Service for OIDC authentication operations supporting multiple providers."""

    def __init__(self):
        # Cache per provider: {provider_id: config}
        self._configs: Dict[str, OIDCConfig] = {}
        # JWKS cache per provider: {provider_id: jwks}
        self._jwks_caches: Dict[str, Dict[str, Any]] = {}
        # JWKS cache time per provider: {provider_id: datetime}
        self._jwks_cache_times: Dict[str, datetime] = {}
        self._jwks_cache_ttl = timedelta(hours=1)

    async def get_oidc_config(self, provider_id: str) -> OIDCConfig:
        """Fetch OIDC configuration from discovery endpoint for specific provider."""
        # Check if any OIDC providers are enabled
        if not settings_manager.is_oidc_enabled():
            raise HTTPException(
                status_code=status.HTTP_501_NOT_IMPLEMENTED,
                detail="OIDC authentication is not enabled",
            )

        # Get provider configuration
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        if not provider_config.get("enabled", False):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"OIDC provider '{provider_id}' is not enabled",
            )

        discovery_url = provider_config.get("discovery_url")
        if not discovery_url:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"OIDC discovery URL not configured for provider '{provider_id}'",
            )

        # Return cached config if available
        if provider_id in self._configs:
            return self._configs[provider_id]

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(discovery_url, timeout=10.0)
                response.raise_for_status()
                config_data = response.json()

            config = OIDCConfig(**config_data)
            self._configs[provider_id] = config
            logger.info(f"Loaded OIDC config for provider '{provider_id}' from {discovery_url}")
            return config

        except httpx.HTTPError as e:
            logger.error(f"Failed to fetch OIDC configuration for '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail=f"Unable to connect to OIDC provider '{provider_id}'",
            )
        except Exception as e:
            logger.error(f"Error parsing OIDC configuration for '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Invalid OIDC provider configuration for '{provider_id}'",
            )

    def generate_state(self) -> str:
        """Generate a secure random state parameter for CSRF protection."""
        return secrets.token_urlsafe(32)

    def generate_authorization_url(
        self, provider_id: str, config: OIDCConfig, state: str, redirect_uri: Optional[str] = None
    ) -> str:
        """Generate the authorization URL for OIDC login."""
        # Get provider configuration
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        # Use provider-specific settings
        client_id = provider_config.get("client_id", settings.oidc_client_id)
        scopes = provider_config.get("scopes", settings.oidc_scopes)
        
        # Fallback to global redirect URI if not specified
        if not redirect_uri:
            redirect_uri = settings.oidc_redirect_uri

        scopes_str = " ".join(scopes)

        params = {
            "client_id": client_id,
            "response_type": "code",
            "scope": scopes_str,
            "redirect_uri": redirect_uri,
            "state": state,
        }

        # Build query string
        query_params = "&".join(f"{k}={httpx.URL('').copy_with(params={k: v}).params[k]}" for k, v in params.items())
        return f"{config.authorization_endpoint}?{query_params}"

    async def exchange_code_for_tokens(
        self, provider_id: str, code: str, redirect_uri: Optional[str] = None
    ) -> Dict[str, Any]:
        """Exchange authorization code for tokens."""
        config = await self.get_oidc_config(provider_id)
        
        # Get provider configuration
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        # Use provider-specific settings
        client_id = provider_config.get("client_id", settings.oidc_client_id)
        client_secret = provider_config.get("client_secret", settings.oidc_client_secret)
        
        # Fallback to global redirect URI if not specified
        if not redirect_uri:
            redirect_uri = settings.oidc_redirect_uri

        token_data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": redirect_uri,
            "client_id": client_id,
            "client_secret": client_secret,
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    config.token_endpoint,
                    data=token_data,
                    headers={"Content-Type": "application/x-www-form-urlencoded"},
                    timeout=10.0,
                )
                response.raise_for_status()
                return response.json()

        except httpx.HTTPError as e:
            logger.error(f"Token exchange failed for provider '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Failed to exchange authorization code for tokens with provider '{provider_id}'",
            )

    async def get_jwks(self, provider_id: str) -> Dict[str, Any]:
        """Fetch and cache JWKS from the OIDC provider."""
        # Return cached JWKS if still valid
        if (
            provider_id in self._jwks_caches
            and provider_id in self._jwks_cache_times
            and datetime.now(timezone.utc) - self._jwks_cache_times[provider_id] < self._jwks_cache_ttl
        ):
            return self._jwks_caches[provider_id]

        config = await self.get_oidc_config(provider_id)

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(config.jwks_uri, timeout=10.0)
                response.raise_for_status()
                jwks = response.json()

            self._jwks_caches[provider_id] = jwks
            self._jwks_cache_times[provider_id] = datetime.now(timezone.utc)
            logger.debug(f"JWKS cache updated for provider '{provider_id}'")
            return jwks

        except httpx.HTTPError as e:
            logger.error(f"Failed to fetch JWKS for provider '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail=f"Unable to fetch OIDC signing keys from provider '{provider_id}'",
            )

    async def verify_id_token(self, provider_id: str, id_token: str) -> Dict[str, Any]:
        """Verify and decode ID token from OIDC provider."""
        config = await self.get_oidc_config(provider_id)
        jwks = await self.get_jwks(provider_id)

        # Get provider configuration
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        client_id = provider_config.get("client_id", settings.oidc_client_id)

        try:
            # Decode header to get kid
            unverified_header = jwt.get_unverified_header(id_token)
            kid = unverified_header.get("kid")

            # Find matching key in JWKS
            key = None
            for jwk_key in jwks.get("keys", []):
                if jwk_key.get("kid") == kid:
                    key = jwk_key
                    break

            if not key:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail=f"Unable to find matching signing key for provider '{provider_id}'",
                )

            # Verify and decode token
            # Note: We disable access_token validation since at_hash is optional
            # and we're not using it for additional validation
            claims = jwt.decode(
                id_token,
                key,
                algorithms=["RS256", "RS384", "RS512"],
                audience=client_id,
                issuer=config.issuer,
                options={
                    "verify_at_hash": False  # Disable at_hash validation
                }
            )

            return claims

        except JWTError as e:
            logger.error(f"ID token verification failed for provider '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Invalid ID token from provider '{provider_id}'",
            )

    async def get_user_info(self, provider_id: str, access_token: str) -> Dict[str, Any]:
        """Fetch user information from the userinfo endpoint."""
        config = await self.get_oidc_config(provider_id)

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    config.userinfo_endpoint,
                    headers={"Authorization": f"Bearer {access_token}"},
                    timeout=10.0,
                )
                response.raise_for_status()
                return response.json()

        except httpx.HTTPError as e:
            logger.error(f"Failed to fetch user info from provider '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Failed to fetch user information from provider '{provider_id}'",
            )

    def extract_user_data(self, provider_id: str, claims: Dict[str, Any]) -> Dict[str, Any]:
        """Extract user data from OIDC claims using provider-specific claim mappings."""
        # Get provider configuration for claim mappings
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        claim_mappings = provider_config.get("claim_mappings", {})
        username_claim = claim_mappings.get("username", settings.oidc_claim_username)
        email_claim = claim_mappings.get("email", settings.oidc_claim_email)
        name_claim = claim_mappings.get("name", settings.oidc_claim_name)

        # Log available claims for debugging
        logger.debug(f"Available claims in ID token from '{provider_id}': {list(claims.keys())}")
        logger.debug(f"Looking for username claim: '{username_claim}'")

        username = claims.get(username_claim)
        email = claims.get(email_claim)
        name = claims.get(name_claim, username)

        if not username:
            logger.error(f"Username claim '{username_claim}' not found in token from provider '{provider_id}'")
            logger.error(f"Available claims: {claims}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Username claim '{username_claim}' not found in token from provider '{provider_id}'",
            )

        logger.info(f"Extracted user data from provider '{provider_id}': username={username}, email={email}, name={name}")

        return {
            "username": username,
            "email": email,
            "realname": name,
            "sub": claims.get("sub"),
            "provider_id": provider_id,
        }

    async def provision_or_get_user(self, provider_id: str, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """Provision a new user or get existing user from OIDC data."""
        # Get provider configuration
        provider_config = settings_manager.get_oidc_provider(provider_id)
        if not provider_config:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"OIDC provider '{provider_id}' not found",
            )

        auto_provision = provider_config.get("auto_provisioning", {}).get("enabled", settings.oidc_auto_provision)

        from services.user_management import (
            get_user_by_username,
            create_user,
            update_user,
        )
        from models.user_management import UserRole

        username = user_data["username"]
        user = get_user_by_username(username)

        if user:
            # Update user information if changed
            updates = {}
            if user_data.get("email") and user.get("email") != user_data["email"]:
                updates["email"] = user_data["email"]
            if user_data.get("realname") and user.get("realname") != user_data["realname"]:
                updates["realname"] = user_data["realname"]

            if updates:
                user = update_user(user["id"], **updates)
                logger.info(f"Updated OIDC user '{username}' from provider '{provider_id}'")

            return user

        # Create new user if auto-provisioning is enabled
        if not auto_provision:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"User does not exist and auto-provisioning is disabled for provider '{provider_id}'",
            )

        try:
            # Generate a random password (won't be used for OIDC login)
            random_password = secrets.token_urlsafe(32)

            # Get default role from provider config or use 'user'
            default_role_str = provider_config.get("auto_provisioning", {}).get("default_role", "user")
            default_role = UserRole.user if default_role_str == "user" else UserRole.admin

            user = create_user(
                username=username,
                realname=user_data.get("realname", username),
                password=random_password,
                email=user_data.get("email"),
                role=default_role,
                debug=False,
            )

            logger.info(f"Auto-provisioned new OIDC user '{username}' from provider '{provider_id}' with role '{default_role_str}'")
            return user

        except Exception as e:
            logger.error(f"Failed to provision OIDC user from provider '{provider_id}': {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to provision user account from provider '{provider_id}'",
            )


# Global OIDC service instance
oidc_service = OIDCService()
